# SwiftCompress Module Structure

**Version**: 1.0
**Last Updated**: 2025-10-07

This document defines the file and directory organization for the SwiftCompress project, establishing naming conventions, module boundaries, and structural guidelines.

---

## Directory Structure Overview

```
swiftcompress/
├── Podfile                           # CocoaPods dependency specification
├── Podfile.lock                      # Locked dependency versions
├── swiftcompress.xcodeproj/          # Xcode project files
├── swiftcompress.xcworkspace/        # Xcode workspace (generated by CocoaPods)
├── README.md                         # Project overview and usage
├── CHANGELOG.md                      # Version history
├── LICENSE                           # MIT License
│
├── Documentation/                    # Architecture and design docs
│   ├── architecture_overview.md
│   ├── component_specifications.md
│   ├── module_structure.md
│   ├── error_handling_strategy.md
│   ├── testing_strategy.md
│   └── ADRs/
│       ├── ADR-001-clean-architecture.md
│       ├── ADR-002-protocol-abstraction.md
│       ├── ADR-003-stream-processing.md
│       ├── ADR-004-dependency-injection.md
│       └── ADR-005-explicit-algorithm-selection.md
│
├── Sources/                          # All production source code
│   ├── CLI/                          # CLI Interface Layer
│   │   ├── main.swift
│   │   ├── ArgumentParser.swift
│   │   ├── CommandRouter.swift
│   │   └── OutputFormatter.swift
│   │
│   ├── Application/                  # Application Layer
│   │   ├── Commands/
│   │   │   ├── Command.swift         # Protocol definition
│   │   │   ├── CompressCommand.swift
│   │   │   └── DecompressCommand.swift
│   │   ├── CommandExecutor.swift
│   │   └── ErrorHandler.swift
│   │
│   ├── Domain/                       # Domain Layer
│   │   ├── CompressionEngine.swift
│   │   ├── AlgorithmRegistry.swift
│   │   ├── FilePathResolver.swift
│   │   ├── ValidationRules.swift
│   │   │
│   │   └── Protocols/                # Domain protocol definitions
│   │       ├── CompressionAlgorithm.swift
│   │       ├── FileHandler.swift
│   │       ├── OutputWriter.swift
│   │       └── StreamProcessor.swift
│   │
│   ├── Infrastructure/               # Infrastructure Layer
│   │   ├── FileSystemHandler.swift
│   │   ├── StreamProcessor.swift
│   │   │
│   │   └── Algorithms/               # Algorithm implementations
│   │       ├── LZFSEAlgorithm.swift
│   │       ├── LZ4Algorithm.swift
│   │       ├── ZlibAlgorithm.swift
│   │       └── LZMAAlgorithm.swift
│   │
│   └── Shared/                       # Shared types and utilities
│       ├── Errors/
│       │   ├── SwiftCompressError.swift
│       │   ├── DomainErrors.swift
│       │   ├── ApplicationErrors.swift
│       │   └── InfrastructureErrors.swift
│       │
│       ├── Models/
│       │   ├── ParsedCommand.swift
│       │   ├── CommandType.swift
│       │   ├── CommandResult.swift
│       │   └── UserFacingError.swift
│       │
│       └── Extensions/
│           ├── String+Validation.swift
│           ├── URL+Paths.swift
│           └── Data+Compression.swift
│
└── Tests/                            # All test code
    ├── UnitTests/
    │   ├── CLI/
    │   │   ├── ArgumentParserTests.swift
    │   │   ├── CommandRouterTests.swift
    │   │   └── OutputFormatterTests.swift
    │   │
    │   ├── Application/
    │   │   ├── CompressCommandTests.swift
    │   │   ├── DecompressCommandTests.swift
    │   │   ├── CommandExecutorTests.swift
    │   │   └── ErrorHandlerTests.swift
    │   │
    │   ├── Domain/
    │   │   ├── CompressionEngineTests.swift
    │   │   ├── AlgorithmRegistryTests.swift
    │   │   ├── FilePathResolverTests.swift
    │   │   └── ValidationRulesTests.swift
    │   │
    │   └── Infrastructure/
    │       ├── FileSystemHandlerTests.swift
    │       ├── StreamProcessorTests.swift
    │       └── Algorithms/
    │           ├── LZFSEAlgorithmTests.swift
    │           ├── LZ4AlgorithmTests.swift
    │           ├── ZlibAlgorithmTests.swift
    │           └── LZMAAlgorithmTests.swift
    │
    ├── IntegrationTests/
    │   ├── CompressionIntegrationTests.swift
    │   ├── DecompressionIntegrationTests.swift
    │   ├── FileOperationsIntegrationTests.swift
    │   └── ErrorHandlingIntegrationTests.swift
    │
    ├── E2ETests/
    │   ├── CLIExecutionTests.swift
    │   ├── ScriptabilityTests.swift
    │   └── ErrorScenarioTests.swift
    │
    └── TestHelpers/
        ├── Mocks/
        │   ├── MockFileHandler.swift
        │   ├── MockCompressionAlgorithm.swift
        │   ├── MockStreamProcessor.swift
        │   └── MockAlgorithmRegistry.swift
        │
        ├── Fixtures/
        │   ├── TestFiles/              # Sample files for testing
        │   │   ├── small.txt
        │   │   ├── medium.bin
        │   │   ├── large.dat
        │   │   └── corrupted.lzfse
        │   │
        │   └── ExpectedResults/        # Expected compression results
        │       └── checksums.json
        │
        └── TestUtilities.swift         # Shared test utilities
```

---

## Layer Organization Principles

### 1. CLI Interface Layer (`Sources/CLI/`)

**Purpose**: Entry point and user interface handling

**File Organization**:
- `main.swift`: Application entry point, dependency setup
- `ArgumentParser.swift`: CLI argument parsing
- `CommandRouter.swift`: Command routing logic
- `OutputFormatter.swift`: Output formatting for terminal

**Naming Conventions**:
- Entry point: `main.swift` (required by Swift)
- Components: `<Component>.<responsibility>.swift`
- Example: `ArgumentParser.swift`, not `Parser.swift`

**Dependencies**:
- Can depend on: Application layer protocols
- Cannot depend on: Domain or Infrastructure implementations

**Guidelines**:
- Keep main.swift minimal (dependency wiring only)
- Each file contains one primary class/struct
- No business logic in this layer

---

### 2. Application Layer (`Sources/Application/`)

**Purpose**: Application workflows and orchestration

**File Organization**:
- `Commands/`: Command pattern implementations
  - `Command.swift`: Protocol definition
  - `<CommandName>Command.swift`: Concrete commands
- Root level: Executors and handlers

**Naming Conventions**:
- Commands: `<Action>Command.swift` (e.g., `CompressCommand.swift`)
- Protocols: `<Name>Protocol.swift` or defined in `<Name>.swift`
- Handlers: `<Purpose>Handler.swift` (e.g., `ErrorHandler.swift`)

**Dependencies**:
- Can depend on: Domain layer protocols and models
- Cannot depend on: Infrastructure implementations
- Can depend on: Shared types

**Guidelines**:
- Each command is self-contained in its own file
- Protocol and implementation can share a file if tightly coupled
- Orchestration logic only, no business rules

---

### 3. Domain Layer (`Sources/Domain/`)

**Purpose**: Core business logic and abstractions

**File Organization**:
- Root level: Core domain services
- `Protocols/`: Domain protocol definitions

**Naming Conventions**:
- Services: `<ServiceName>.swift` (e.g., `CompressionEngine.swift`)
- Protocols: `<Name>Protocol.swift` (e.g., `CompressionAlgorithmProtocol.swift`)
- When protocol and implementation share file: `<Name>.swift`

**Dependencies**:
- Cannot depend on: Any other layer
- Can depend on: Shared types only
- Pure business logic

**Guidelines**:
- This layer should have zero external dependencies
- All protocols defined in `Protocols/` subdirectory
- Each service in its own file
- No Foundation/UIKit dependencies if possible

---

### 4. Infrastructure Layer (`Sources/Infrastructure/`)

**Purpose**: External system integration implementations

**File Organization**:
- Root level: System integrations (FileSystem, Streams)
- `Algorithms/`: Compression algorithm implementations

**Naming Conventions**:
- Adapters: `<System>Adapter.swift` or `<System>Handler.swift`
- Algorithms: `<AlgorithmName>Algorithm.swift`
- Example: `LZFSEAlgorithm.swift`, not `LZFSE.swift`

**Dependencies**:
- Can depend on: Domain protocols
- Can depend on: System frameworks (Foundation, Compression)
- Cannot depend on: Application or CLI layers

**Guidelines**:
- Each algorithm in separate file
- Implementations follow domain protocols
- Isolate framework dependencies
- Make implementations swappable

---

### 5. Shared Types (`Sources/Shared/`)

**Purpose**: Cross-cutting concerns and common types

**File Organization**:
- `Errors/`: Error type definitions
- `Models/`: Data transfer objects and value types
- `Extensions/`: Swift extension methods

**Naming Conventions**:
- Errors: `<Layer>Errors.swift` or `<Specific>Error.swift`
- Models: `<ModelName>.swift`
- Extensions: `<Type>+<Purpose>.swift`

**Dependencies**:
- No dependencies on any layer
- Foundation framework only
- Pure data structures

**Guidelines**:
- Keep types simple and focused
- Group related errors in same file
- Extensions grouped by extended type

---

## Test Organization Principles

### Unit Tests (`Tests/UnitTests/`)

**Structure**: Mirror production code structure

**Naming Convention**: `<ComponentName>Tests.swift`

**Organization**:
- Each test file corresponds to one production file
- Tests grouped by functionality within file
- Use `// MARK:` comments for test grouping

**Example**:
```swift
// CompressCommandTests.swift
import XCTest
@testable import swiftcompress

final class CompressCommandTests: XCTestCase {
    // MARK: - Setup
    // MARK: - Output Path Resolution Tests
    // MARK: - Validation Tests
    // MARK: - Execution Tests
    // MARK: - Error Handling Tests
}
```

---

### Integration Tests (`Tests/IntegrationTests/`)

**Structure**: Organized by feature or workflow

**Naming Convention**: `<Feature>IntegrationTests.swift`

**Organization**:
- Test multi-component interactions
- Use real implementations where possible
- Mock only external systems

**Example**:
- `CompressionIntegrationTests.swift`: Full compression workflow
- `FileOperationsIntegrationTests.swift`: File I/O with real FileManager

---

### E2E Tests (`Tests/E2ETests/`)

**Structure**: Organized by user scenarios

**Naming Convention**: `<Scenario>Tests.swift`

**Organization**:
- Test full CLI execution
- Use Process to invoke binary
- Validate stdout/stderr/exit codes

**Example**:
- `CLIExecutionTests.swift`: Command-line invocation scenarios
- `ScriptabilityTests.swift`: Shell scripting scenarios

---

### Test Helpers (`Tests/TestHelpers/`)

**Structure**:
- `Mocks/`: Mock implementations for testing
- `Fixtures/`: Test data files
- Root: Shared test utilities

**Naming Conventions**:
- Mocks: `Mock<Component>.swift`
- Fixtures: Descriptive names (`small.txt`, `corrupted.lzfse`)

**Guidelines**:
- Reusable mocks for all protocols
- Fixtures version-controlled
- Test utilities for common assertions

---

## File Naming Conventions

### Swift Files

**Pattern**: `<PrimaryType>.swift`

**Examples**:
- `CompressionEngine.swift` (contains `CompressionEngine` class)
- `Command.swift` (contains `Command` protocol)
- `SwiftCompressError.swift` (contains error types)

**Guidelines**:
- One primary type per file
- File name matches primary type name
- Supporting types can be included if tightly coupled

---

### Protocol Files

**Pattern**: `<ProtocolName>.swift` or `<Name>Protocol.swift`

**Examples**:
- `Command.swift` (contains `Command` protocol only)
- `CompressionAlgorithmProtocol.swift` (explicitly named protocol)

**Preference**: Use simple name without "Protocol" suffix unless ambiguous

---

### Test Files

**Pattern**: `<ComponentName>Tests.swift`

**Examples**:
- `CompressCommandTests.swift`
- `LZFSEAlgorithmTests.swift`
- `CompressionIntegrationTests.swift`

**Guidelines**:
- Always suffix with "Tests"
- Mirror production file names
- Integration/E2E tests describe scenarios

---

### Mock Files

**Pattern**: `Mock<Component>.swift`

**Examples**:
- `MockFileHandler.swift`
- `MockCompressionAlgorithm.swift`

**Guidelines**:
- Always prefix with "Mock"
- Implement all protocol methods
- Make behavior configurable

---

## Access Control Guidelines

### Layer Access Rules

**Public** (Exported from module):
- Protocol definitions in Domain layer
- Error types
- Main entry point

**Internal** (Default):
- Most implementations
- Command classes
- Infrastructure adapters

**Private**:
- Implementation details
- Helper methods
- Internal state

### File-Level Organization

**Recommended Structure**:
```swift
// 1. Imports
import Foundation
import Compression

// 2. Protocol definitions (if any)
protocol CompressionAlgorithmProtocol { ... }

// 3. Main type (public/internal)
final class LZFSEAlgorithm: CompressionAlgorithmProtocol { ... }

// 4. Extensions (grouped by protocol/functionality)
extension LZFSEAlgorithm {
    // Private helpers
}

// 5. Supporting types (if needed)
private struct CompressionContext { ... }
```

---

## Import Organization

### Import Order

1. System frameworks (alphabetical)
2. Third-party dependencies (alphabetical)
3. Internal modules (alphabetical)

**Example**:
```swift
import Compression
import Foundation

// Third-party (from CocoaPods)
import ArgumentParser  // Hypothetical CLI library

// Internal (if using modules)
@testable import swiftcompress
```

### Import Guidelines

- Use explicit imports only
- Avoid `import *` patterns
- `@testable` import only in test files
- Document why importing if non-obvious

---

## MARK Comments for Organization

### Standard MARK Sections

**For Classes/Structs**:
```swift
class CompressCommand {
    // MARK: - Properties
    // MARK: - Initialization
    // MARK: - Public Methods
    // MARK: - Private Methods
    // MARK: - Protocol Conformance
}
```

**For Test Classes**:
```swift
class CompressCommandTests: XCTestCase {
    // MARK: - Setup and Teardown
    // MARK: - <Feature> Tests
    // MARK: - Error Handling Tests
    // MARK: - Edge Case Tests
}
```

### MARK Usage Guidelines

- Use `// MARK: -` for major sections (includes separator line)
- Use `// MARK:` for subsections
- Keep section names descriptive
- Maintain consistent ordering across files

---

## Documentation Comments

### Documentation Standard

Use Swift Documentation Markup for all public and internal types:

```swift
/// Compresses a file using the specified algorithm.
///
/// This method orchestrates the compression workflow by:
/// 1. Validating input and output paths
/// 2. Selecting the appropriate algorithm
/// 3. Processing the file through the compression engine
///
/// - Parameters:
///   - inputPath: Path to the file to compress
///   - algorithmName: Name of the compression algorithm (lzfse, lz4, zlib, lzma)
///   - outputPath: Optional output path. If nil, uses default naming convention
///
/// - Throws:
///   - `FileNotFoundError` if input file doesn't exist
///   - `InvalidAlgorithmError` if algorithm name is unsupported
///   - `CompressionFailedError` if compression operation fails
///
/// - Returns: Path to the compressed file
func compress(inputPath: String, algorithmName: String, outputPath: String?) throws -> String
```

### Documentation Requirements

**Must Document**:
- All public types and methods
- All protocols
- Complex algorithms or logic
- Error conditions

**Should Document**:
- Internal types with non-obvious behavior
- Protocol conformance rationale

**Can Skip**:
- Private methods with obvious purpose
- Simple getters/setters
- Test methods (use descriptive names instead)

---

## Code Organization Best Practices

### File Size Guidelines

**Target**:
- **Ideal**: 200-300 lines per file
- **Maximum**: 500 lines per file

**If exceeding**:
- Split into multiple files
- Extract protocols to separate files
- Move private types to separate files

### Type Organization Within File

**Order**:
1. Type definition and properties
2. Initialization
3. Public interface methods
4. Internal methods
5. Private methods
6. Protocol conformance (in extensions)
7. Supporting private types

### Grouping Related Files

**Use Subdirectories For**:
- Related protocols (`Domain/Protocols/`)
- Related implementations (`Infrastructure/Algorithms/`)
- Command implementations (`Application/Commands/`)

**Don't Over-Nest**:
- Maximum 2-3 levels of nesting
- Prefer flat structure when possible

---

## Xcode Project Organization

### Group Structure (mirrors file system)

```
swiftcompress (Xcode Project)
├── Sources
│   ├── CLI
│   ├── Application
│   ├── Domain
│   ├── Infrastructure
│   └── Shared
├── Tests
│   ├── UnitTests
│   ├── IntegrationTests
│   ├── E2ETests
│   └── TestHelpers
├── Documentation
└── Products
```

### Target Configuration

**Main Target**: `swiftcompress`
- Type: Command Line Tool
- Language: Swift
- Deployment Target: macOS 12.0+

**Test Target**: `swiftcompressTests`
- Type: Unit Test Bundle
- Host Application: None (CLI tool)

---

## Podfile Organization

### Recommended Podfile Structure

```ruby
# Podfile
platform :osx, '12.0'

target 'swiftcompress' do
  # Use frameworks for Swift projects
  use_frameworks!

  # CLI argument parsing
  pod 'Swift-Argument-Parser', '~> 1.2'  # Example

  target 'swiftcompressTests' do
    inherit! :search_paths
    # Test-specific dependencies if needed
  end
end
```

### Dependency Management Guidelines

- Pin major versions (`~> 1.2` allows updates to 1.x)
- Document why each dependency is needed
- Keep dependencies minimal
- Prefer Swift-native libraries
- Review dependencies for macOS compatibility

---

## Configuration Files

### Essential Configuration Files

**Podfile**: CocoaPods dependency specification
**Podfile.lock**: Locked dependency versions (commit this!)
**.gitignore**: Exclude build artifacts, Pods/, derived data
**.swiftlint.yml**: Swift linting rules (recommended)
**README.md**: Project overview and setup instructions

### Gitignore Recommendations

```gitignore
# Xcode
*.xcodeproj/*
!*.xcodeproj/project.pbxproj
!*.xcodeproj/xcshareddata/
xcuserdata/
DerivedData/
*.xcworkspace/
!Podfile.lock

# CocoaPods
Pods/

# Swift Package Manager (if used)
.build/
Package.resolved

# OS files
.DS_Store
```

---

## Build Configuration

### Recommended Build Settings

**Optimization**:
- Debug: `-Onone` (no optimization)
- Release: `-O` (optimize for speed)

**Swift Language Version**: 5.9+

**Warnings as Errors**: Enabled in Release builds

**Code Coverage**: Enabled for test builds

---

## Migration and Refactoring Guidelines

### Adding New Components

1. **Determine layer**: Choose appropriate architectural layer
2. **Define protocol**: Create protocol in Domain if needed
3. **Create file**: Follow naming conventions
4. **Add tests**: Create corresponding test file
5. **Update documentation**: Add to relevant architecture docs

### Refactoring Existing Components

1. **Maintain structure**: Keep layer organization
2. **Update tests**: Refactor tests alongside implementation
3. **Document changes**: Update architecture docs if structure changes
4. **Preserve backwards compatibility**: If public interface changes

---

## Validation Checklist

Before committing code, verify:

- [ ] File in correct layer directory
- [ ] File name follows conventions
- [ ] Import statements organized correctly
- [ ] MARK comments for organization
- [ ] Documentation comments for public APIs
- [ ] Corresponding test file exists
- [ ] Access control appropriate for layer
- [ ] No circular dependencies between layers
- [ ] Xcode project structure mirrors file system

---

## Future Considerations

### Modularity (Future Phase)

Consider splitting into Swift Package Manager modules:
- `SwiftCompressCore` (Domain + Application)
- `SwiftCompressCLI` (CLI Interface)
- `SwiftCompressInfrastructure` (Infrastructure)

**Benefits**:
- Enforce layer boundaries at compile time
- Enable library reuse
- Faster build times (incremental compilation)

**When to Modularize**:
- Project exceeds 10,000 lines
- Multiple clients need core functionality
- Build times become problematic

---

## Additional Resources

### Related Documentation

- **architecture_overview.md**: High-level architecture principles
- **component_specifications.md**: Detailed component responsibilities
- **testing_strategy.md**: Testing approach and standards
- **error_handling_strategy.md**: Error type definitions and handling

### Useful References

- [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)
- [Swift File and Folder Structure](https://github.com/raywenderlich/swift-style-guide)
- [Clean Architecture in iOS](https://clean-swift.com/)

---

This module structure provides a clear, scalable foundation for organizing the SwiftCompress codebase while maintaining architectural boundaries and supporting future growth.
